import React from "react";
import { render, screen, fireEvent, waitFor, cleanup } from "@testing-library/react";
import "@testing-library/jest-dom";
import LoginPage from "./page";

// mock RoleContext.useRole
jest.mock("@/context/RoleContext", () => ({ useRole: jest.fn() }));
const { useRole } = require("@/context/RoleContext") as { useRole: jest.Mock };

// mock next/navigation useRouter
jest.mock("next/navigation", () => ({ useRouter: jest.fn() }));
const { useRouter } = require("next/navigation") as { useRouter: jest.Mock };

beforeEach(() => {
  jest.resetAllMocks();
  cleanup();
});

test("renders email/password inputs and sign in button", () => {
  useRole.mockReturnValue({ login: jest.fn() });
  useRouter.mockReturnValue({ replace: jest.fn() });

  render(<LoginPage />);

  expect(screen.getByPlaceholderText("Email")).toBeInTheDocument();
  expect(screen.getByPlaceholderText("Password")).toBeInTheDocument();
  expect(screen.getByRole("button", { name: /Sign in/i })).toBeInTheDocument();
});

test("successful login calls login and navigates to /", async () => {
  let resolveLogin: (v: boolean) => void;
  const loginMock = jest.fn(
    () =>
      new Promise<boolean>((res) => {
        resolveLogin = res;
      })
  );
  const replace = jest.fn();
  useRole.mockReturnValue({ login: loginMock });
  useRouter.mockReturnValue({ replace });

  render(<LoginPage />);

  fireEvent.change(screen.getByPlaceholderText("Email"), { target: { value: "a@b.com" } });
  fireEvent.change(screen.getByPlaceholderText("Password"), { target: { value: "secret" } });

  const btn = screen.getByRole("button", { name: /Sign in/i });
  fireEvent.click(btn);

  // while pending, button should be disabled and show signing in text
  expect(btn).toBeDisabled();
  expect(btn).toHaveTextContent("Signing in…");
  expect(loginMock).toHaveBeenCalledWith("a@b.com", "secret");

  // resolve login -> navigation should occur
  resolveLogin!(true);
  await waitFor(() => expect(replace).toHaveBeenCalledWith("/"));
});

test("failed login shows error and does not navigate", async () => {
  const loginMock = jest.fn().mockResolvedValue(false);
  const replace = jest.fn();
  useRole.mockReturnValue({ login: loginMock });
  useRouter.mockReturnValue({ replace });

  render(<LoginPage />);

  fireEvent.change(screen.getByPlaceholderText("Email"), { target: { value: "no@one.com" } });
  fireEvent.change(screen.getByPlaceholderText("Password"), { target: { value: "bad" } });

  fireEvent.click(screen.getByRole("button", { name: /Sign in/i }));

  await waitFor(() => expect(screen.getByText("Invalid email or password.")).toBeInTheDocument());
  expect(replace).not.toHaveBeenCalled();
});
```// filepath: c:\Users\gagan\OneDrive\Desktop\main\CSCI-275-main\src\app\login\page.test.tsx
import React from "react";
import { render, screen, fireEvent, waitFor, cleanup } from "@testing-library/react";
import "@testing-library/jest-dom";
import LoginPage from "./page";

// mock RoleContext.useRole
jest.mock("@/context/RoleContext", () => ({ useRole: jest.fn() }));
const { useRole } = require("@/context/RoleContext") as { useRole: jest.Mock };

// mock next/navigation useRouter
jest.mock("next/navigation", () => ({ useRouter: jest.fn() }));
const { useRouter } = require("next/navigation") as { useRouter: jest.Mock };

beforeEach(() => {
  jest.resetAllMocks();
  cleanup();
});

test("renders email/password inputs and sign in button", () => {
  useRole.mockReturnValue({ login: jest.fn() });
  useRouter.mockReturnValue({ replace: jest.fn() });

  render(<LoginPage />);

  expect(screen.getByPlaceholderText("Email")).toBeInTheDocument();
  expect(screen.getByPlaceholderText("Password")).toBeInTheDocument();
  expect(screen.getByRole("button", { name: /Sign in/i })).toBeInTheDocument();
});

test("successful login calls login and navigates to /", async () => {
  let resolveLogin: (v: boolean) => void;
  const loginMock = jest.fn(
    () =>
      new Promise<boolean>((res) => {
        resolveLogin = res;
      })
  );
  const replace = jest.fn();
  useRole.mockReturnValue({ login: loginMock });
  useRouter.mockReturnValue({ replace });

  render(<LoginPage />);

  fireEvent.change(screen.getByPlaceholderText("Email"), { target: { value: "a@b.com" } });
  fireEvent.change(screen.getByPlaceholderText("Password"), { target: { value: "secret" } });

  const btn = screen.getByRole("button", { name: /Sign in/i });
  fireEvent.click(btn);

  // while pending, button should be disabled and show signing in text
  expect(btn).toBeDisabled();
  expect(btn).toHaveTextContent("Signing in…");
  expect(loginMock).toHaveBeenCalledWith("a@b.com", "secret");

  // resolve login -> navigation should occur
  resolveLogin!(true);
  await waitFor(() => expect(replace).toHaveBeenCalledWith("/"));
});

test("failed login shows error and does not navigate", async () => {
  const loginMock = jest.fn().mockResolvedValue(false);
  const replace = jest.fn();
  useRole.mockReturnValue({ login: loginMock });
  useRouter.mockReturnValue({ replace });

  render(<LoginPage />);

  fireEvent.change(screen.getByPlaceholderText("Email"), { target: { value: "no@one.com" } });
  fireEvent.change(screen.getByPlaceholderText("Password"), { target: { value: "bad" } });

  fireEvent.click(screen.getByRole("button", { name: /Sign in/i }));

  await waitFor(() => expect(screen.getByText("Invalid email or password.")).toBeInTheDocument());
  expect(replace).not.toHaveBeenCalled();
});